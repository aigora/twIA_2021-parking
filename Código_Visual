#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include "SerialClass/SerialClass.h" // Biblioteca para acceder al puerto serie
#include<string.h>
#define aforo 15
#define TARIFA 5
#define DIM 8

typedef struct {

	float hora_entrada, hora_salida;
	char matricula[DIM];
}COCHE;

void registro(char matricula[], float hora_entrada, int coches);
void entrada(int coches, COCHE*);
void salida(int coches, COCHE*);
float tarifa(float hora_entrada, float hora_salida);

int main() {

	COCHE plazas[aforo];


	int  coches = 0, i, bytesRecibidos;
	float precio, importe_introducido;
	char opc, BufferEntrada[100], BufferSalida[100];

	Arduino = new Serial((char*)puerto); // Crea conexión lógica con Arduino

	do {

		while (Arduino->IsConnected())
		{
			printf("Arduino conectado\n");
			Sleep(1000);
			system("cls");

			printf("\t\t\tBIENVENIDO, PRESIONE EL BOTON PARA CONTINUAR\n");

			Sleep(2000); // Tiempo de espera para el resto de las tramas
			bytesRecibidos = Arduino->ReadData(BufferEntrada, sizeof(char) * 99);
			if (bytesRecibidos != -1) // Lectura de mensaje desde el puerto
			{
				BufferEntrada[bytesRecibidos - 1] = '\0';
				printf("Recibidos %d bytes: %s\n", bytesRecibidos, BufferEntrada);
				switch (BufferEntrada) {

				case 'e':
					entrada(coches, &plazas[coches]);
					coches++;
					break;

				case 's':
					salida(coches, &plazas[coches]);
					coches--;
					break;

				default:
					printf("Opcion incorrecta\n\n");
				}
			}
			else
				printf("No se ha recibido nada\n");
			Sleep(1000);
		}

	} while (coches < aforo);

	system("cls");

	printf("\t\t\tAFORO COMPLETO, POR FAVOR DE LA VUELTA\n\n\n");
}

void entrada(int coches, COCHE* plazas) {

	printf("Introduzca su matricula: ");
	getchar();
	gets_s(plazas[coches].matricula);

	printf("Introduzca la hora de entrada: ");
	scanf_s("%f", &plazas[coches].hora_entrada);

	registro(plazas[coches].matricula, plazas[coches].hora_entrada, coches);

	printf("\n\nOk, puede entrar\n\n");

	while (bytesRecibidos == -1)
	{
		strcpy_s(BufferSalida, "Registro completado");
		//printf("Enviando %s\n", BufferSalida);
		Arduino->WriteData(BufferSalida, strlen(BufferSalida)); // Envía mensaje
		contador++;
		if (contador == 1)
			Sleep(2000); // Tiempos de espera para la primera trama (evita pérdidas)
		else
			Sleep(2000); // Tiempo de espera para el resto de las tramas
		bytesRecibidos = Arduino->ReadData(BufferEntrada, sizeof(char) * 99);
		if (bytesRecibidos != -1) // Lectura de mensaje desde el puerto
		{
			BufferEntrada[bytesRecibidos - 1] = '\0';
			//printf("Recibidos %d bytes: %s\n", bytesRecibidos, BufferEntrada);
		}
		else
			//printf("No se ha recibido nada\n");
			Sleep(1000);
	}

	Sleep(2000);

	system("cls");
}

void registro(char matricula_e[], float hora_entrada, int coches) { //HAY QUE REVISARLO

	FILE* pf;

	errno_t err; // Open for read (will fail if file "registro.txt" doesn't exist)

	err = fopen_s(&pf, "registro.txt", "a+");

	if (err == 0) {

		printf("El archivo registro.txt esta abierto\n");

		fprintf_s(pf, "%s %.2f\n", matricula_e, hora_entrada);
	}

	else
		printf("El archivo registro.txt NO está abierto\n");

	if (fclose(pf) == NULL)
		printf("\n Archivo cerrado correctamente");
	else
		printf("\n Error en el cierre del archivo");
}

void salida(int coches, COCHE* plazas) {

	int i = -1;
	float importe_introducido = 0, importe_introducido2 = 0, precio;
	char matricula_sal[DIM];

	printf("Introduzca su matricula: ");
	getchar();
	gets_s(matricula_sal);

	do {  //comprobar si la matricula coincide con alguna del registro

		if (matricula_sal[DIM - 1] == plazas[i].matricula[DIM - 1]) {  //si coincide:

			printf("Introduzca la hora actual: ");
			scanf_s("%f", &plazas[i].hora_salida);

			precio = tarifa(plazas[i].hora_entrada, plazas[i].hora_salida);
			printf("El importe asciende a %.2f EUROS, introduzcalos por favor: ", precio);
			scanf_s("%f", &importe_introducido);

			if (importe_introducido < precio) {

				printf("Le falta introducir %.2f EUROS, introduzcalos por favor: ", (precio - importe_introducido));
				scanf_s("%f", &importe_introducido2);
				importe_introducido += importe_introducido2;
			}

			if (importe_introducido > precio) {
				printf("Se le han devuelto %.2f EUROS, recojalos por favor ", (importe_introducido - precio));
			}

			printf("\nBuen viaje\n");

			while (bytesRecibidos == -1)
			{
				strcpy_s(BufferSalida, "Pago realizado");
				//printf("Enviando %s\n", BufferSalida);
				Arduino->WriteData(BufferSalida, strlen(BufferSalida)); // Envía mensaje
				contador++;
				if (contador == 1)
					Sleep(2000); // Tiempos de espera para la primera trama (evita pérdidas)
				else
					Sleep(2000); // Tiempo de espera para el resto de las tramas
				bytesRecibidos = Arduino->ReadData(BufferEntrada, sizeof(char) * 99);
				if (bytesRecibidos != -1) // Lectura de mensaje desde el puerto
				{
					BufferEntrada[bytesRecibidos - 1] = '\0';
					//printf("Recibidos %d bytes: %s\n", bytesRecibidos, BufferEntrada);
				}
				else
					//printf("No se ha recibido nada\n");
					Sleep(1000);
			}

			coches--;

			Sleep(2000);

			system("cls");
		}

		i++;

	} while (matricula_sal[DIM - 1] != plazas[i].matricula[DIM - 1] && i < coches);

}

float tarifa(float hora_entrada, float hora_salida) {

	float precio, tiempo;

	tiempo = hora_salida - hora_entrada;
	precio = tiempo * TARIFA;

	return precio;
}
